""" Utilities for combining profile and SSP evol fits to assess membership probabilities

Restarting from scratch
"""
from __future__ import print_function
import numpy as np
import scipy.ndimage as ndimage
import pylab as plt

from astropy.io import fits as pyfits
from astropy import wcs
from libs.ezdata import SimpleTable as Table    # simpletable

from libs import setup_mpl
from libs import figrc
setup_mpl.theme()


# path to results -- Path corresponds to the location of the different files
data_path = {
    # images used for the profile fit
    'image475': 'ap{apid}/ap{apid}_F475W.fits',
    # match results
    'match_output': 'ap{apid}/console_ap{apid}.txt',
    'match_sfh': 'ap{apid}/param.sfh',
    'match_cmd': 'ap{apid}/ap{apid}_out.cmd',
    'match_fake': 'ap{apid}/ap{apid}_fake.dat',
    'match_sky': 'ap{apid}/ap{apid}_sky.fits',
    'match_bg': 'ap{apid}/bg.dat',
    # photometric catalog from PHAT
    'phot': 'ap{apid}/ap{apid}_phot.fits'
}


# CMD catalog from match outputs
match_dtype = [('mag', float), ('color', float),
               ('n_obs', float), ('n_mod', float),
               ('n_diff', float), ('sig', float)]


def get_fake_params(data):
    """
    Convenience function to produce param file contents for match/fake:

    The parameter file will contain the following definitions:

    .. code::

         IMF (m-M)o Av Zspread BF dmag_min
         Vstep V-Istep fake_sm V-Imin V-Imax V,I
         Vmin Vmax V
         Imin Imax I
         Ntbins
         To Tf SFR Z
         SFR : Msuns/yr

    Parameters
    ----------
    data: dictionary
        cluster data

    Returns
    -------
    params: str
        parameter content that can be save into an ascii file
    """
    grid = data['match']['grid']
    select = np.argmin(grid['fit'])
    params = ['-1.00 24.47 {0:.2f} 0.1 0.35 -1.50'.format(grid['av'][select])]
    params.append(''.join(data['match']['params'][4:7])[:-1])
    params.append('1')
    agebin_start = grid['age'][select]
    sfr = grid['sfr'][select]
    z = grid['z'][select]
    params.append('{0:.2f} {1:.2f} {2:.2e} {3:.2f}'.format(agebin_start,
                                                           agebin_start + 0.1,
                                                           sfr * data['match']['sfr_scale'], z)
                  )
    return "\n".join(params)


def run_match_fake(data):
    """ Run Fake to generate a synthetic CMD

    Parameters
    ----------
    data: dictionary
        cluster data

    Returns
    -------
    fake_stars: recarray
        population of stars drawn for the model and generated by Fake
    """
    import subprocess
    import os

    match_cfg = {
        'fake_path': '/usr/local/bin/match2.5/bin/fake',
        'fake_opts': ('-dAvy=0.0', '-dAv=0.0', '-full')
    }

    fn_tmp_params = data['match']['fake'].replace('dat', 'params')
    fn_tmp_output = data['match']['fake'].replace('dat', 'out')

    if not os.path.exists(fn_tmp_output):
        with open(fn_tmp_params, 'w') as f:
            f.write(get_fake_params(data))

        cmd = [match_cfg['fake_path'], fn_tmp_params, fn_tmp_output,
               '-fake={0}'.format(data['match']['fake'])]
        cmd.extend(match_cfg['fake_opts'])

        if not os.path.exists(match_cfg['fake_path']):
            print("Run \n {0}".format(' '.join(cmd)))
            raise RuntimeError('Match:fake executable not found')
        try:
            p = subprocess.check_output(cmd, stderr=subprocess.STDOUT)
            print(p)
        except Exception as e:
            print(e)
            return
    else:
        print('loading previous version from {0}'.format(fn_tmp_output))

    fake_dtype = [
        ('F475W_VEGA', float), ('F814W_VEGA', float),
        ('mass', float), ('Mbol', float), ('logTeff', float),
        ('logg', float), ('logZ', float), ('C/O', float),
        ('Av', float), ('age', float)
    ]

    match_fake_stars = np.loadtxt(fn_tmp_output, dtype=fake_dtype)

    w_recovered = np.where((match_fake_stars['F475W_VEGA'] < 99) &
                           (match_fake_stars['F814W_VEGA'] < 99))

    if w_recovered[0].size == 0:
        raise RuntimeError("Synthetic CMD is empty")

    return match_fake_stars[w_recovered]


def get_cluster_data(clid, *args, **kwargs):
    """ Creates a container of all important data related to a cluster

    Parameters
    ----------
    clid: int
        cluster id

    Returns
    -------
    data: dict
        dictionary of all related information
    """

    if ('ap' not in clid.lower()):
        raise NotImplemented('synthetics not implemented yet.')

    apid = int(clid[2:])

    # read profile data
    profile_image = pyfits.getdata(data_path['image475'].format(apid=apid))
    profile_header = pyfits.getheader(data_path['image475'].format(apid=apid))
    profile_wcs = wcs.find_all_wcs(profile_header)[0]

    # read MATCH data
    match_output = np.genfromtxt(data_path['match_output'].format(apid=apid), skip_header=10, skip_footer=2)
    with open(data_path['match_sfh'].format(apid=apid), 'r') as f:
        match_params = f.readlines()

    match_cmd = np.loadtxt(data_path['match_cmd'].format(apid=apid), skiprows=4, dtype=match_dtype)
    match_fakepath = data_path['match_fake'].format(apid=apid)
    bg_stars = Table(data_path['match_sky'].format(apid=apid), caseless=True)
    match_bg = np.loadtxt(data_path['match_bg'].format(apid=apid),
                          dtype=[('F475W_VEGA', float), ('F814W_VEGA', float)])

    # photometric catalog
    phot = Table(data_path['phot'].format(apid=apid), caseless=True)
    # convert stars ra,dec to pixels
    stars_xy = profile_wcs.wcs_world2pix(np.column_stack([phot['ra'], phot['dec']]), 0)
    sky_xy = profile_wcs.wcs_world2pix(np.column_stack([bg_stars['ra'], bg_stars['dec']]), 0)

    # extract color-mag
    keys = ','.join(phot.keys())
    if ('vega' in keys) or ('VEGA' in keys):
        color_name = 'F475W-F814W'
        mag_name = 'F475W'
        color = phot('F475W_VEGA-F814W_VEGA')
        mag = phot('F475W_VEGA')
        sky_color = bg_stars('F475W_VEGA-F814W_VEGA')
        sky_mag = bg_stars('F475W_VEGA')

    data = {
        'apid': apid,
        'profile': {
            'image': profile_image,
            'header': profile_header,
            'wcs': profile_wcs
        },
        'match': {
            'output': match_output,
            'params': match_params,
            'cmd': match_cmd,
            'bg': match_bg,
            'sky': bg_stars,
            'fake': match_fakepath,
            'sky_xy': sky_xy,
            'sky_color': sky_color,
            'sky_mag': sky_mag
        },
        'phot': {
            'cat': phot,
            'xy': stars_xy,
            'color': color,
            'mag': mag,
            'color_name': color_name,
            'mag_name': mag_name
        }
    }

    return data


def extract_match_results(data):
    """ Update data to extract Match results into some fields """
    if 'match' not in data:
        raise AttributeError('Does not have match data')

    match = data['match']

    output = match['output']

    av = output[:,0]
    age = output[:,3]
    z = output[:,4]
    fit = output[:, 5]
    sfr = output[:,6]
    bg_weight = output[:, 7]
    bg_fudge = output[:,8]

    # Pr = exp(-0.5 * fit) Cash likelihood defined.
    fit -= fit.min()

    params = match['params']
    magstep, colorstep = np.array(params[4].split()[:2], dtype=float)
    bg_kernel = float(params[-2].split()[1])

    # calculate mass
    mass = np.log10(sfr * (10 ** (age + 0.1) - 10 ** age) + 1 )

    match['grid'] = {
        'av': av,
        'age': age,
        'z': z,
        'fit': fit,
        'sfr': sfr,
        'mass': mass,
        'bg_weight': bg_weight,
        'bg_fudge': bg_fudge,
    }

    # SFR scaling for use in populating fake CMD
    match['sfr_scale'] = 100

    match['magstep'] = magstep
    match['colorstep'] = colorstep
    match['bg_kernel'] = bg_kernel

    return data


def get_bins_from_center(c):
    """ Get bin edges from a series of bin centers """
    bins = np.zeros(len(c) + 1, dtype=c.dtype)
    bins[1:-1] = 0.5 * (c[1:] + c[:-1])
    bins[0] = c[0] - 0.5 * (c[1] - c[0])
    bins[-1] = c[-1] + 0.5 * (c[-1] - c[-2])
    return bins


def get_pmem_from_match(cldata, color, mag):
    """ Compute the odd of a given (color, mag) measurement to be part of the cluster

    Returns
    -------
    pmem: ndarray
        Log-odds
    cl_im: ndarray (ncolor, nmag)
        cluster probability density
    """
    # make full model
    cmd = cldata['match']['cmd']
    x = cmd['color']
    y = cmd['mag']
    dx = get_bins_from_center(np.unique(x))
    dy = get_bins_from_center(np.unique(y))
    sky_color, sky_mag = cldata['match']['sky_color'], cldata['match']['sky_mag']

    nsky, bx, by = np.histogram2d(sky_color, sky_mag, bins=(dx,dy))
    nmod, bx, by = np.histogram2d(cmd['color'], cmd['mag'], bins=(dx,dy), weights=cmd['n_mod'])

    # sky background smoothing similarly to match internal smoothing.
    ndimage.gaussian_filter(nsky, cldata['match']['bg_kernel'], output=nsky)

    # get best fit model
    grid = cldata['match']['grid']
    match_select = np.argmin(grid['fit'])
    bg_weight = grid['bg_weight'][match_select]

    # cluster model
    sky_im = np.clip(nsky * bg_weight, 0, 1)
    cl_im = np.clip((nmod - nsky * bg_weight), 0, 1)

    im = np.log10(cl_im + 1e-4) - np.log10(sky_im + 1e-4)

    vx = np.digitize(color, bx) - 1
    vy = np.digitize(mag, by) - 1
    pmem = np.zeros(len(mag))

    ind = (vx >= 0) & (vx < len(bx) - 1) & (vy >= 0) & (vy < len(by) - 1)
    pmem[ind] = im[vx[ind], vy[ind]]

    return pmem, cl_im, (bx, by)


def imshow(image, nsig=3, ax=None, **kwargs):
    """ add the sigma clip to the pylab.imshow function
    This function works exactly as the traditional imshow function, however
    adds a sigma stretching to the image.
    Any keyword of imshow will take over the sigma behavior.
    By default, aspect is 'equal', origin is 'lower'.

    Parameters
    ----------
    image: ndarray[ndim>=2]
        image to show
    nsig: float
            number of sigma to stretch
    ax: plt.Axes
        axes to use for the figure ( default gca() )

    **kwargs are forwarded to the traditional imshow
    """
    mean = np.mean(image)
    std = np.std(image)

    defaults = {'origin': 'lower', 'interpolation': 'nearest', 'cmap': plt.cm.gray,
                'vmin': mean - nsig * std, 'vmax': mean + nsig * std,
                'aspect': 'equal'
                }
    defaults.update(**kwargs)
    if ax is None:
        ax = plt.gca()
    return ax.imshow(image, **defaults)


def plot_cmd(data, c='k', **kwargs):
    if 'ax' in kwargs:
        ax = kwargs.pop('ax')
    else:
        ax = plt.gca()
    phot = data['phot']
    sc = ax.scatter(phot['color'], phot['mag'], c=c, **kwargs)
    match = data['match']
    sc = ax.plot(match['sky_color'], match['sky_mag'], '.', color='0.8', zorder=-100)
    ax.set_ylim(28, 20)
    ax.set_xlim(-1, 7)
    ax.set_xlabel(phot['color_name'])
    ax.set_ylabel(phot['mag_name'])
    return sc


def plot_data(cldata):
    plt.figure(figsize=(15,5))

    ax = plt.subplot(131)
    im = cldata['profile']['image']
    imshow(im, aspect='auto')
    figrc.hide_axis('top right'.split())
    plt.title('F475W image')

    plt.subplot(132, sharex=ax, sharey=ax)
    x, y = cldata['phot']['xy'].T
    plt.scatter(x, y, c='k', alpha=0.5, edgecolor='None')
    sx, sy = cldata['match']['sky_xy'].T
    plt.plot(sx, sy, '.', color='0.8', alpha=0.5, zorder=-100)
    ax.set_xlim(0, im.shape[1])
    ax.set_ylim(0, im.shape[0])
    #plt.xlim(50, 250)
    #plt.ylim(50, 250)
    figrc.hide_axis('top right'.split())
    plt.title('catalog positions')

    plt.subplot(133)
    plot_cmd(cldata, alpha=0.5)
    plt.title('catalog CMD')
    figrc.hide_axis('top right'.split())
    plt.tight_layout()


def plot_joint_av_age_pdf(cldata):
    """ plot p(av, logage | cluster) """

    grid = cldata['match']['grid']
    pr = np.exp(-0.5 * grid['fit'])
    x = np.unique(grid['av'])
    y = np.unique(grid['age'])
    bins = (get_bins_from_center(x), get_bins_from_center(y))

    n, bx, by = plt.histogram2d(grid['av'], grid['age'], weights=pr, bins=bins)
    floor = n[n > 0].min()
    plt.imshow(np.log10(n + 1e-3 * floor).T, origin='lower', extent=(bx[0], bx[-1], by[0], by[-1]),
               cmap=plt.cm.magma, aspect='auto', interpolation='nearest')
    plt.contour(n.T, figrc.nice_sigma_levels(n, [1,2,3]), extent=(bx[0], bx[-1], by[0], by[-1]), colors='k')
    plt.xlabel('Av')
    plt.ylabel('Log Age')


def plot_joint_mass_age_pdf(cldata):
    """ plot p(logmass, logage | cluster) """

    grid = cldata['match']['grid']
    pr = np.exp(-0.5 * grid['fit'])
    y = np.unique(grid['age'])
    dlogm = 0.1
    bins = (np.arange(dlogm, 6, dlogm), get_bins_from_center(y))

    n, bx, by = plt.histogram2d(grid['mass'], grid['age'], weights=pr, bins=bins)
    floor = n[n > 0].min()
    plt.imshow(np.log10(n + 1e-3 * floor).T, origin='lower', extent=(bx[0], bx[-1], by[0], by[-1]),
               cmap=plt.cm.magma, aspect='auto', interpolation='nearest')
    plt.contour(n.T, figrc.nice_sigma_levels(n, [1,2,3]), extent=(bx[0], bx[-1], by[0], by[-1]), colors='k')
    plt.xlabel('Log mass')
    plt.ylabel('Log age')


def plot_1d_pdfs(cldata):
    grid = cldata['match']['grid']
    logpr = grid['fit']
    pr = np.exp(-0.5 * logpr)
    pr /= pr.sum()

    plt.figure(figsize=(15,4))

    plt.subplot(141)
    y = np.unique(grid['age'])
    dy = get_bins_from_center(y)
    n, b = plt.histogram(cldata['match']['grid']['age'], bins=dy, weights=pr)
    c = figrc.get_centers_from_bins(b)
    p = n * np.diff(b) * c
    plt.step(10 ** c, p / p.sum(), where='mid', color='k', lw=2)
    plt.xscale('log')
    figrc.hide_axis('top right'.split())
    plt.xlabel('age [yr]')

    plt.subplot(142)
    Y = grid['av']
    y = np.unique(Y)
    dy = get_bins_from_center(y)
    n, b = plt.histogram(Y, bins=dy, weights=pr)
    c = figrc.get_centers_from_bins(b)
    plt.step(c, n / n.sum(), where='mid', color='k', lw=2)
    figrc.hide_axis('top right'.split())
    plt.xlabel('Av [mag]')

    plt.subplot(143)
    Y = grid['z']
    y = np.unique(Y)
    dy = get_bins_from_center(y)
    n, b = plt.histogram(Y, bins=dy, weights=pr)
    c = figrc.get_centers_from_bins(b)
    plt.step(c, n / n.sum(), where='mid', color='k', lw=2)
    figrc.hide_axis('top right'.split())
    plt.xlabel(r'Log(Z/Z$_\odot$)')

    plt.subplot(144)
    Y = grid['mass']
    dlogm = 0.1
    y = np.unique(Y)
    dy = np.arange(dlogm, 6, dlogm)
    n, b = plt.histogram(Y, bins=dy, weights=pr)
    c = figrc.get_centers_from_bins(b)
    p = n * np.diff(b) * c
    # plt.step(c, n / n.sum(), where='mid')
    plt.step(10 ** c, p / p.sum(), where='mid', color='k', lw=2)
    plt.xscale('log')
    figrc.hide_axis('top right'.split())
    plt.xlabel(r'Mass [M$_\odot$]')

    plt.tight_layout()


def plot_cmd_with_model(cldata):
    cmd = cldata['match']['cmd']
    x = cmd['color']
    y = cmd['mag']
    dx = get_bins_from_center(np.unique(x))
    dy = get_bins_from_center(np.unique(y))
    plt.figure()
    plot_cmd(cldata, c='w', edgecolor='k', alpha=1.)
    n, bx, by = plt.histogram2d(cmd['color'], cmd['mag'], bins=(dx,dy), weights=cmd['n_mod'])
    plt.imshow(n.T, origin='lower', extent=(bx[0], bx[-1], by[0], by[-1]),
               cmap=plt.cm.Blues, aspect='auto', interpolation='nearest')
    # plt.ylim(plt.ylim()[1], 20)
    plt.xlim(bx[0], bx[-1])
    plt.ylim(by[-1], 20)
    figrc.hide_axis('top right'.split())
    plt.colorbar()
    plt.tight_layout()


def plot_match_cmd_results(cldata):

    cmd = cldata['match']['cmd']
    x = cmd['color']
    y = cmd['mag']
    dx = get_bins_from_center(np.unique(x))
    dy = get_bins_from_center(np.unique(y))
    plt.figure(figsize=(10,8))

    ax = plt.subplot(221)
    n, bx, by = plt.histogram2d(cmd['color'], cmd['mag'], bins=(dx,dy), weights=cmd['n_obs'])
    plt.imshow(n.T, origin='lower', extent=(bx[0], bx[-1], by[0], by[-1]),
               cmap=plt.cm.gray_r, aspect='auto', interpolation='nearest')
    figrc.hide_axis('top right'.split())
    plt.colorbar()
    plt.title('observed')

    plt.subplot(222, sharex=ax, sharey=ax)
    n, bx, by = plt.histogram2d(cmd['color'], cmd['mag'], bins=(dx,dy), weights=cmd['n_mod'])
    plt.imshow(n.T, origin='lower', extent=(bx[0], bx[-1], by[0], by[-1]),
               cmap=plt.cm.gray_r, aspect='auto', interpolation='nearest')
    figrc.hide_axis('top right'.split())
    plt.colorbar()
    plt.title('modeled')

    plt.subplot(223, sharex=ax, sharey=ax)
    n, bx, by = plt.histogram2d(cmd['color'], cmd['mag'], bins=(dx,dy), weights=cmd['n_diff'])
    plt.imshow(n.T, origin='lower', extent=(bx[0], bx[-1], by[0], by[-1]),
               cmap=plt.cm.gray_r, aspect='auto', interpolation='nearest')
    figrc.hide_axis('top right'.split())
    plt.colorbar()
    plt.title('residuals')

    plt.subplot(224, sharex=ax, sharey=ax)
    n, bx, by = plt.histogram2d(cmd['color'], cmd['mag'], bins=(dx,dy), weights=cmd['sig'])
    plt.imshow(n.T, origin='lower', extent=(bx[0], bx[-1], by[0], by[-1]),
               cmap=plt.cm.gray_r, aspect='auto', interpolation='nearest')

    plt.ylim(plt.ylim()[1], 20)
    figrc.hide_axis('top right'.split())
    plt.colorbar()
    plt.title('significance')

    plt.tight_layout()


def plot_logOddsCmd(cldata):
    phot = cldata['phot']
    color, mag = phot['color'], phot['mag']
    sky_color, sky_mag = cldata['match']['sky_color'], cldata['match']['sky_mag']
    pmem, im, (bx, by) = get_pmem_from_match(cldata, color, mag)
    sky_pmem, _, _ = get_pmem_from_match(cldata, sky_color, sky_mag)

    lim = np.max(np.abs(pmem))
    plt.scatter(sky_color, sky_mag, c=sky_pmem, cmap=plt.cm.RdBu, edgecolor='None', vmin=-lim, vmax=lim)
    plt.scatter(color, mag, c=pmem, cmap=plt.cm.RdBu, edgecolor='0.5', vmin=-lim, vmax=lim)
    #ind = pmem > 0.3
    #plt.scatter(color[ind], mag[ind], c=pmem[ind], cmap=plt.cm.cubehelix_r, vmin=0, edgecolor='r')
    cb = plt.colorbar(extend='both')
    lim = np.max(np.abs(pmem))

    cb.set_ticks(np.arange(-int(lim + 1), int(lim + 1), 1, dtype=int))
    cb.set_label('Log Odds(cluster/field)')

    plt.ylim(by[-1], 20)
    plt.xlim(bx[0], bx[-1])
    figrc.hide_axis('top right'.split())
    plt.xlabel(cldata['phot']['color_name'])
    plt.ylabel(cldata['phot']['mag_name'])


def plot_prclusterCmd(cldata):
    phot = cldata['phot']
    color, mag = phot['color'], phot['mag']
    sky_color, sky_mag = cldata['match']['sky_color'], cldata['match']['sky_mag']
    pmem, im, (bx, by) = get_pmem_from_match(cldata, color, mag)
    sky_pmem, _, _ = get_pmem_from_match(cldata, sky_color, sky_mag)

    plt.imshow(im.T,
               origin='lower', extent=(bx[0], bx[-1], by[0], by[-1]),
               cmap=plt.cm.cubehelix_r, aspect='auto', interpolation='nearest')
    plt.colorbar().set_label('p(color, mag | cluster)')

    plt.scatter(color, mag, c='k', edgecolor='0.8')
    # sc = plt.plot(sky_color, sky_mag, '.', color='0.8')

    figrc.hide_axis('top right'.split())
    plt.ylim(by[-1], 20)
    plt.xlim(bx[0], bx[-1])
    plt.xlabel(cldata['phot']['color_name'])
    plt.ylabel(cldata['phot']['mag_name'])


def plot_prskyCmd(cldata):

    # make full model
    cmd = cldata['match']['cmd']
    x = cmd['color']
    y = cmd['mag']
    dx = get_bins_from_center(np.unique(x))
    dy = get_bins_from_center(np.unique(y))
    sky_color, sky_mag = cldata['match']['sky_color'], cldata['match']['sky_mag']

    nsky, bx, by = np.histogram2d(sky_color, sky_mag, bins=(dx,dy))
    nmod, bx, by = np.histogram2d(cmd['color'], cmd['mag'], bins=(dx,dy), weights=cmd['n_mod'])

    # sky background smoothing similarly to match internal smoothing.
    ndimage.gaussian_filter(nsky, cldata['match']['bg_kernel'], output=nsky)

    # get best fit model
    grid = cldata['match']['grid']
    match_select = np.argmin(grid['fit'])
    bg_weight = grid['bg_weight'][match_select]

    # cluster model
    sky_im = np.clip(nsky * bg_weight, 0, 1)

    phot = cldata['phot']
    color, mag = phot['color'], phot['mag']

    plt.imshow(sky_im.T,
               origin='lower', extent=(bx[0], bx[-1], by[0], by[-1]),
               cmap=plt.cm.cubehelix_r, aspect='auto', interpolation='nearest')
    plt.colorbar().set_label('p(color, mag | field)')

    plt.scatter(color, mag, c='k', edgecolor='0.8')
    # sc = plt.plot(sky_color, sky_mag, '.', color='0.8')

    figrc.hide_axis('top right'.split())
    plt.ylim(by[-1], 20)
    plt.xlim(bx[0], bx[-1])
    plt.xlabel(cldata['phot']['color_name'])
    plt.ylabel(cldata['phot']['mag_name'])
